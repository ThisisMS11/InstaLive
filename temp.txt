const ffmpeg2 = (youtube, twitch, facebook, customRTMP) => {
  return [
    '-i',
    '-',
    // select first stream intended for output
    '-map',
    '0',
    // video codec config: low latency, adaptive bitrate
    '-c:v',
    'libx264',
    '-preset',
    'veryfast',
    '-tune',
    'zerolatency',
    '-g:v',
    '60',

    // audio codec config: sampling frequency (11025, 22050, 44100), bitrate 64 kbits
    '-c:a',
    'aac',
    '-strict',
    '-2',
    '-ar',
    '44100',
    '-b:a',
    '64k',

    //force to overwrite
    '-y',

    // used for audio sync
    '-use_wallclock_as_timestamps',
    '1',
    '-async',
    '1',

    '-flags',
    '+global_header',
    '-f',
    'tee',
    `[f=flv:onfail=ignore]${youtube}|[f=flv:onfail=ignore]${twitch}|[f=flv:onfail=ignore]${facebook}|[f=flv:onfail=ignore]${customRTMP}`,
  ]
}

module.exports.ffmpeg2 = ffmpeg2



const express = require('express');
const cors = require('cors');
const { Server } = require('socket.io');
const dotenv = require('dotenv');
const { youtubeSettings, inputSettings } = require('./ffmpeg');
const child_process = require('child_process');

dotenv.config();

const app = express();
const PORT = process.env.PORT || 8000;

app.use(cors());
app.use(express.json({ limit: '200mb', extended: true }));
app.use(express.urlencoded({ limit: '200mb', extended: true, parameterLimit: 50000 }));

app.get('/', (req, res) => {
    res.send("Server is up and running");
});

const server = require('http').createServer(app);

const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

io.on('connection', (socket) => {
    console.log(`Socket connected to ${socket.id}`);
    const youtubeUrl = socket.handshake.query.youtubeUrl;

    const ffmpegInput = inputSettings.concat(youtubeSettings(youtubeUrl))

    const ffmpeg = child_process.spawn('ffmpeg', ffmpegInput);

    ffmpeg.on('close', (code, signal) => {
        console.log('FFmpeg child process closed, code ' + code + ', signal ' + signal);
    });

    ffmpeg.stdin.on('error', (e) => {
        console.log('FFmpeg STDIN Error', e);
    });

    ffmpeg.stderr.on('data', (data) => {
        console.log('FFmpeg STDERR:', data.toString());
    });

    socket.on('message', (msg) => {
        console.log('DATA', msg);
        ffmpeg.stdin.write(msg);
    });

    socket.conn.on('close', (e) => {
        console.log('kill: SIGINT');
        ffmpeg.kill('SIGINT');
    });
});

server.listen(PORT, () => {
    console.log(`Listening on PORT ${PORT} for REST API requests`);
});



import express, { json, urlencoded } from 'express';
import cors from 'cors';
import { Server } from 'socket.io';
import { config } from 'dotenv';
import ffmpeg from 'fluent-ffmpeg';
import { PassThrough } from 'stream';
import { fileTypeFromBuffer } from 'file-type';
import http from 'http';

config();

const app = express();
const PORT = process.env.PORT || 8000;

app.use(cors());
app.use(json({ limit: '200mb', extended: true }));
app.use(urlencoded({ limit: '200mb', extended: true, parameterLimit: 50000 }));

app.get('/', (req, res) => {
    res.send("Server is up and running");
});

const server = http.createServer(app);

const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

io.on('connection', (socket) => {
    console.log(`Socket connected to ${socket.id}`);
    const youtubeUrl = socket.handshake.query.youtubeUrl;

    let accumulatedBuffer = Buffer.alloc(0);
    const minimumBufferLength = 512; // Adjust based on your needs

    // Create a PassThrough stream to handle incoming data
    const stream = new PassThrough();

    // .inputFormat('v4l2')  // Video format (adjust for your OS)
    // .videoCodec('libx264')
    // .audioCodec('aac')
    // .outputOptions([
    //   '-preset veryfast',     // Preset for encoding speed vs compression
    //   '-tune zerolatency',    // Tune for low latency
    //   '-g 60',                // GOP size (number of frames between keyframes)
    //   '-strict -2'            // Necessary for some AAC codecs
    // ])
    // .output(YOUTUBE_RTMP_URL)
    // .format('flv');
    // Set up FFmpeg to read from the PassThrough stream
    const ffmpegCommand = ffmpeg(stream)
        .inputFormat('webm')
        .videoCodec('libx264')
        .audioCodec('aac')
        .outputOptions([
            '-preset veryfast',
            '-tune zerolatency',
            '-g 60',
            '-strict -2',
            '-ar 44100',
            '-use_wallclock_as_timestamps 1',
            '-async 1',
        ])
        .format('flv')
        .output(youtubeUrl)
        .on('start', commandLine => {
            console.log('FFmpeg command: ' + commandLine);
        })
        .on('error', (err, stdout, stderr) => {
            console.log('Error: ' + err.message);
            console.log('FFmpeg stderr: ' + stderr);
        })
        .on('end', () => {
            console.log('Streaming ended.');
        });


    ffmpegCommand.run();


    socket.on('message', async (chunk) => {
        accumulatedBuffer = Buffer.concat([accumulatedBuffer, chunk]);

        // Check if accumulatedBuffer has enough data
        if (accumulatedBuffer.length >= minimumBufferLength) {
            try {
                const type = await fileTypeFromBuffer(accumulatedBuffer);
                console.log('Detected type:', type);

                if (type) {
                    stream.write(accumulatedBuffer);
                    accumulatedBuffer = Buffer.alloc(0); // Reset accumulated buffer
                } else {
                    console.warn('Unsupported file type or incomplete buffer');
                }
            } catch (error) {
                console.error('Error processing message:', error);
            }
        }
    });

    socket.conn.on('close', (e) => {
        console.log('kill: SIGINT');
        ffmpegCommand.kill('SIGINT');
    });
});

server.listen(PORT, () => {
    console.log(`Listening on PORT ${PORT} for REST API requests`);
});




'use client';

import React, { useEffect, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import {
    Card,
    CardContent,
    CardFooter,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import classNames from 'classnames';
import { Video, VideoOff, Mic, MicOff } from 'lucide-react';
import { useStudio } from "@/app/context/StudioContext";
import { io } from 'socket.io-client';
import axios from "axios";
import { type } from "os";


export default function StudioEntry() {

    const videoRef = useRef<HTMLVideoElement>(null);
    // const audioRef = useRef<HTMLAudioElement>(null);

    const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);

    const socket = useRef<any>(null);
    // const mediaRecorder = useRef<MediaRecorder | null>(null);

    let liveStreamRecorder;


    const { isVideoOn, setIsVideoOn, isAudioOn, setIsAudioOn, displayName } = useStudio();

    // const [audioLevel, setAudioLevel] = useState<number>(0);
    // const [audioContext, setAudioContext] = useState<AudioContext | null>(null);

    const handleVideoToggle = () => {
        if (isVideoOn) stopVideo();
        else startVideo();

        setIsVideoOn(!isVideoOn);
    };

    const handleAudioToggle = () => {
        // if (isAudioOn) {
        //     if (audioContext) {
        //         setAudioLevel(0);  // Set audio level to zero immediately
        //         audioContext.suspend(); // Suspend audio context
        //     }
        // } else {
        //     if (!audioContext) {
        //         startAudio(); // Restart audio stream
        //     } else {
        //         audioContext.resume(); // Resume audio context
        //     }
        // }
        setIsAudioOn(!isAudioOn);
    };

    const startVideo = async () => {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            setMediaStream(stream);
            if (videoRef.current) {
                videoRef.current.srcObject = stream;
            }
        } catch (error) {
            console.error("Error accessing webcam:", error);
        }
    };

    const stopVideo = async () => {
        if (mediaStream) {
            mediaStream.getVideoTracks().forEach((track) => {
                track.stop();
            })
        }
    }

    // async function startAudio() {
    //     try {
    //         const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    //         const newAudioContext = new AudioContext();
    //         const source = newAudioContext.createMediaStreamSource(stream);
    //         const analyser = newAudioContext.createAnalyser();
    //         source.connect(analyser);
    //         analyser.fftSize = 256;
    //         const dataArray = new Uint8Array(analyser.frequencyBinCount);

    //         const analyze = () => {
    //             analyser.getByteFrequencyData(dataArray);
    //             const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
    //             setAudioLevel(average);
    //             requestAnimationFrame(analyze);
    //         };

    //         analyze();
    //         setAudioContext(newAudioContext);
    //     } catch (error) {
    //         console.error("Error accessing microphone:", error);
    //     }
    // }
    const transitionToLive = async () => {
        const url = `${process.env.NEXT_PUBLIC_URL}/api/youtube/broadcast/status`;
        try {
            const response = await axios.put(url, {
                youtubeBroadcastId: "GWodIL8vJ-k",
                status: "testing"
            });
            const data = response.data;
            console.log({ data });
            return data;
        } catch (error) {
            console.error("Some error occurred while updating broadcast status:", error);
            throw error;
        }
    }

    const LiveMe = () => {
        console.log('live Me called');
        const youtubeUrl = "rtmp://a.rtmp.youtube.com/live2/w8vy-4dvt-42ea-5xtg-31zr"
        const url = `http://localhost:8005/?youtubeUrl=${youtubeUrl}`
        socket.current = io(url, {
            transports: ['websocket']
        })

        InitiateRecording();

        // setTimeout(() => {
        //     transitionToLive();
        // }, 10000);
    }

    const InitiateRecording = async () => {
        const videoElement = videoRef.current as HTMLVideoElement & {
            captureStream?(frameRate?: number): MediaStream
        };

        if (videoElement && videoElement.captureStream) {


            const videoStream = videoElement.captureStream(30); // Capture video at 30FPS

            console.log({videoStream})

            try {
                // Capture audio stream
                const audioStream = await navigator.mediaDevices.getUserMedia({ video:true, audio: true });

                // Combine video and audio streams
                const combinedStream = new MediaStream([
                    ...videoStream.getVideoTracks(),
                    ...audioStream.getAudioTracks(),
                ]);

                console.log({combinedStream})

                liveStreamRecorder = new MediaRecorder(combinedStream, {
                    audioBitsPerSecond: 128000,
                    videoBitsPerSecond: 2500000,
                    mimeType: 'video/webm;codecs=vp8,opus',
                    //@ts-ignore
                    framerate: 30,
                });

                liveStreamRecorder.ondataavailable = (e: any) => {
                    console.log('Data is available and sent.');
                    console.log(typeof (e.data));
                    console.log(e.data);

                    socket.current.emit('binarystream', e.data)
                };

                // Start recording and dump data every second
                liveStreamRecorder.start(1000);

            } catch (error) {
                console.error("Error accessing microphone:", error);
            }

        } else {
            console.error("captureStream is not supported on this browser.");
        }
    };

    useEffect(() => {
        if (isVideoOn) {
            console.log("videostaring ....")
            startVideo();
            LiveMe();
        }
        return () => {
            stopVideo();
        };
    }, []);

    useEffect(() => {
        if (!mediaStream) {
            startVideo()
        } else {
            return function cleanup() {
                stopVideo();
            }
        }
    }, [mediaStream])


    return (
        <Card className="grid grid-cols-12">
            {/* <CardHeader>
                <CardTitle className="text-center">Main {displayName}</CardTitle>
            </CardHeader> */}
            <div className="col-span-10 gap-4">

                <CardContent className=" bb items-center justify-center flex flex-col">

                    <div className="w-[65rem] h-[40rem] rounded-lg border bg-card text-card-foreground shadow-sm">
                        <video ref={videoRef} autoPlay className="w-full h-full object-cover" playsInline />
                    </div>
                    {/* <div className="col-span-2 space-y-1.5 rounded-lg border bg-card text-card-foreground shadow-sm">
                        <div ref={audioRef} className="h-full w-full bg-gray-200 relative flex items-end justify-center">
                            <div className={classNames('w-full', { 'bg-red-500': audioLevel > 90, 'bg-orange-500': audioLevel > 60 && audioLevel <= 90, 'bg-green-500': audioLevel <= 60 })} style={{ height: `${audioLevel}%` }}></div>
                        </div>
                    </div> */}

                    {/* ButtonGroup to toggle audio and video */}
                    <div className="bb mt-2 flex justify-center gap-10">
                        <Button onClick={handleAudioToggle}>
                            {isAudioOn ? <Mic /> : <MicOff />}
                        </Button>
                        <Button onClick={handleVideoToggle}>
                            {isVideoOn ? <Video /> : <VideoOff />}
                        </Button>
                    </div>

                </CardContent>
            </div>


        </Card>
    );
}



///  WORKING SERVER CODE : 
import express, { json, urlencoded } from 'express';
import cors from 'cors';
import { Server } from 'socket.io';
import { config } from 'dotenv';
import { spawn } from 'child_process';
// import { fileTypeFromBuffer } from 'file-type';
import http from 'http';

config();

const app = express();
const PORT = process.env.PORT || 8000;

app.use(cors());
app.use(json({ limit: '200mb', extended: true }));
app.use(urlencoded({ limit: '200mb', extended: true, parameterLimit: 50000 }));

app.get('/', (req, res) => {
    res.send("Server is up and running");
});

const server = http.createServer(app);

const io = new Server(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"]
    }
});

ffmpeg -i pipe:0 -i - -acodec aac -b:a 128k -ar 44100 -vcodec libx264 -r 25 -preset ultrafast -tune zerolatency -g 50 -keyint_min 25 -crf 25 -pix_fmt yuv420p -sc_threshold 0 -profile:v main -level 3.1 -f flv rtmp://a.rtmp.youtube.com/live2/w8vy-4dvt-42ea-5xtg-31zr pipe:1

const options = [
    '-i', '-',
    '-c:v', 'libx264',
    '-preset', 'ultrafast',
    '-tune', 'zerolatency',
    '-r', '25',
    '-g', `${25 * 2}`,
    '-keyint_min', 25,
    '-crf', '25',
    '-pix_fmt', 'yuv420p',
    '-sc_threshold', '0',
    '-profile:v', 'main',
    '-level', '3.1',
    '-c:a', 'aac',
    '-b:a', '128k',
    '-ar', '44100',
    '-f', 'flv',
    'rtmp://a.rtmp.youtube.com/live2/kq2g-kfjk-730c-ukjk-100z',
];

const ffmpegProcess = spawn('ffmpeg', options);

ffmpegProcess.stdout.on('data', (data) => {
    console.log(`ffmpeg stdout: ${data}`);
});

ffmpegProcess.stderr.on('data', (data) => {
    console.error(`ffmpeg stderr: ${data}`);
});

ffmpegProcess.on('close', (code) => {
    console.log(`ffmpeg process exited with code ${code}`);
});

io.on('connection', (socket) => {
    console.log(`Socket connected to ${socket.id}`);
    const youtubeUrl = socket.handshake.query.youtubeUrl;

    socket.on('binarystream', (stream) => {
        try {
            ffmpegProcess.stdin.write(stream);
        } catch (err) {
            if (err.code === 'EPIPE') {
                console.log('EPIPE error: FFmpeg process is not writable. Client might have disconnected.');
            } else {
                console.error('Error writing to FFmpeg stdin:', err);
            }
        }
    });

    socket.conn.on('close', () => {
        console.log('Client disconnected, killing FFmpeg process.');
        ffmpegProcess.kill('SIGINT');
    });
});

server.listen(PORT, () => {
    console.log(`Listening on PORT ${PORT} for REST API requests`);
});
